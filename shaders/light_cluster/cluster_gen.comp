#version 460

#include "../include/common.glsl"
#include "../include/types.glsl"

#include "cluster_common.glsl"

layout(push_constant, std430) uniform PushConstants {
	mat4 screen_to_view_matrix;
    
    uvec3 cluster_count;
	uint tile_size_px;
	
    uvec2 screen_size;
	float z_near;
	float z_far;
	
    uint unique_cluster_buffer;
    uint depth_bounds_buffer;
    uint cluster_volume_buffer;
};

layout (local_size_x = 256) in;

vec4 screen_to_view(vec4 screen_pos){
    //Convert to NDC
    vec2 tex_coord = screen_pos.xy / screen_size.xy;

    //Convert to clipSpace
    vec4 clip = vec4(vec2(tex_coord.x, 1.0 - tex_coord.y)* 2.0 - 1.0, screen_pos.z, screen_pos.w);

    //View space transform
    vec4 view = screen_to_view_matrix * clip;

    //Perspective projection
    view = view / view.w;

    return view;
}

vec3 line_intersection_to_z_plane(vec3 a, vec3 b, float z_distance){
    //all clusters planes are aligned in the same z direction
    vec3 normal = vec3(0.0, 0.0, -1.0);
    //getting the line from the eye to the tile
    vec3 ab =  b - a;
    //Computing the intersection length for the line and the plane
    float t = (z_distance - dot(normal, a)) / dot(normal, ab);
    //Computing the actual xyz position of the point along the line
    vec3 result = a + t * ab;
    return result;
}

// http://www.aortiz.me/2018/12/21/CG.html
void main() {
    uint unique_index = gl_GlobalInvocationID.x;
    if (unique_index >= GetBuffer(CompactedClusterIndexList, unique_cluster_buffer).cluster_count) return;
    uint cluster_index = GetBuffer(CompactedClusterIndexList, unique_cluster_buffer).cluster_indices[gl_GlobalInvocationID.x];

    uvec3 cluster_id = cluster_id_from_volume_index(cluster_count, cluster_index);
    const vec3 eye_pos = vec3(0.0);
    
    vec2 min_bounds_screen_space = cluster_id.xy * tile_size_px;
    vec2 max_bounds_screen_space = min(min_bounds_screen_space + tile_size_px, screen_size);

    vec3 min_bounds_view_space = screen_to_view(vec4(min_bounds_screen_space, 1.0, 1.0)).xyz;
    vec3 max_bounds_view_space = screen_to_view(vec4(max_bounds_screen_space, 1.0, 1.0)).xyz;

    float min_depth = 1.0 - uintBitsToFloat(GetBuffer(ClusterDepthBoundsBuffer, depth_bounds_buffer).clusters[cluster_index].min_depth);
    float max_depth = uintBitsToFloat(GetBuffer(ClusterDepthBoundsBuffer, depth_bounds_buffer).clusters[cluster_index].max_depth);

    float cluster_near  = z_near / max_depth;
    float cluster_far   = z_near / min_depth;

    vec3 minPointNear = line_intersection_to_z_plane(eye_pos, min_bounds_view_space, cluster_near);
    vec3 minPointFar  = line_intersection_to_z_plane(eye_pos, min_bounds_view_space, cluster_far );
    vec3 maxPointNear = line_intersection_to_z_plane(eye_pos, max_bounds_view_space, cluster_near);
    vec3 maxPointFar  = line_intersection_to_z_plane(eye_pos, max_bounds_view_space, cluster_far );

    vec3 minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
    vec3 maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

    GetBuffer(ClusterVolumeBuffer, cluster_volume_buffer).clusters[unique_index].min_pos  = vec4(minPointAABB , 0.0);
    GetBuffer(ClusterVolumeBuffer, cluster_volume_buffer).clusters[unique_index].max_pos  = vec4(maxPointAABB , 0.0);
}