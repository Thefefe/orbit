#version 460

#include "include/common.glsl"
#include "include/types.glsl"

#extension GL_EXT_debug_printf : enable

// #define USE_SUBGROUP_OPS

#ifdef USE_SUBGROUP_OPS
	#extension GL_KHR_shader_subgroup_vote : require
	#extension GL_KHR_shader_subgroup_arithmetic : require
	#extension GL_KHR_shader_subgroup_ballot : require
#endif

layout(push_constant, std430) uniform PushConstants {
    uint meshlet_dispatch_buffer;
	uint mesh_info_buffer;
	uint meshlet_buffer;
    uint draw_commands_buffer;
	uint entity_buffer;
	uint cull_info_buffer;
};

layout (local_size_x = 32) in;

float largest_scale_from_matrix(mat3 matrix) {
	vec3 x = matrix[0];
	vec3 y = matrix[1];
	vec3 z = matrix[2];

	float largest_scale_sqr = max(dot(x, x), max(dot(y, y), dot(z, z)));
	return sqrt(largest_scale_sqr);
}

vec4 transform_sphere(mat4 matrix, vec4 sphere) {
	vec4 bounding_sphere = matrix * vec4(sphere.xyz, 1.0);
	bounding_sphere /= bounding_sphere.w;
	bounding_sphere.w = sphere.w * largest_scale_from_matrix(mat3(matrix));

	return bounding_sphere;
}

bool aabb_plane_test(vec3 box_min, vec3 box_max, vec4 plane) {
	vec3 c = (box_max + box_min) * 0.5f; // Compute AABB center
    vec3 e = box_max - c; // Compute positive extents

    // Compute the projection interval radius of b onto L(t) = b.c + t * p.n
    float radius = e.x * abs(plane.x) + e.y * abs(plane.y) + e.z * abs(plane.z);

    float center_distance = dot(plane.xyz, c) - plane.w;

    return center_distance > radius;
}

bool is_aabb_inside_frustum(mat4 mvp_matrix, Aabb aabb, uint plane_mask) {
	bool inside_frustum = true;

	vec3 aabb_min = vec3(aabb.min_pos[0], aabb.min_pos[1], aabb.min_pos[2]);
	vec3 aabb_max = vec3(aabb.max_pos[0], aabb.max_pos[1], aabb.max_pos[2]);

	mat4 mvp_t = transpose(mvp_matrix);
	vec4 planes[6];
	planes[0] = mvp_t[3] + mvp_t[0];
	planes[1] = mvp_t[3] - mvp_t[0];
	planes[2] = mvp_t[3] + mvp_t[1];
	planes[3] = mvp_t[3] - mvp_t[1];
	planes[4] = mvp_t[3] + mvp_t[2];
	planes[5] = mvp_t[3] - mvp_t[2];

	for (uint i = 0; i < 5; i += 1) {
		inside_frustum = inside_frustum && (
			(plane_mask & (1 << i)) == 0 ||
			!aabb_plane_test(aabb_min, aabb_max	, vec4(-planes[i].xyz, planes[i].w))
		);
	}

	return inside_frustum;
}

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
vec4 project_sphere(vec4 sphere, float znear, float P00, float P11) {
	vec4 aabb;
	vec3 C = sphere.xyz;
	float r = sphere.w;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

	return aabb;
}

void main() {
    MeshletDispatch dispatch = GetBuffer(MeshletDispatchBuffer, meshlet_dispatch_buffer).dispatches[gl_GlobalInvocationID.x / 32];

	if (gl_LocalInvocationID.x >= dispatch.meshlet_count) return;

    uint meshlet_index = dispatch.meshlet_offset + gl_LocalInvocationID.x;
	MeshInfo mesh_info = GetBuffer(MeshInfoBuffer, mesh_info_buffer).mesh_infos[dispatch.mesh_index];
    Meshlet meshlet = GetBuffer(MeshletBuffer, meshlet_buffer).meshlets[meshlet_index];

    bool visible = true;

    if (visible) {
        uint data_offset = mesh_info.meshlet_data_offset + meshlet.data_offset;
        uint vertex_offset = mesh_info.vertex_offset + meshlet.vertex_offset;
        MeshletDrawCommand draw_command;
        draw_command.cmd_first_instance    = dispatch.entity_index;
        draw_command.cmd_instance_count    = 1;
        draw_command.cmd_vertex_offset     = int(data_offset);
        draw_command.cmd_first_index       = (data_offset + meshlet.vertex_count) * 4;
        draw_command.cmd_index_count       = meshlet.triangle_count * 3;
        draw_command.meshlet_vertex_offset = vertex_offset;
        draw_command.meshlet_index         = meshlet_index;

        uint draw_index = atomicAdd(GetBuffer(MeshletDrawCommandBuffer, draw_commands_buffer).count, 1);
        GetBuffer(MeshletDrawCommandBuffer, draw_commands_buffer).draws[draw_index] = draw_command;
    }
}