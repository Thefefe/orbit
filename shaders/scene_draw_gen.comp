#version 460

#include "include/common.glsl"
#include "include/types.glsl"

#extension GL_KHR_shader_subgroup_vote : require
#extension GL_KHR_shader_subgroup_arithmetic : require

layout(push_constant, std430) uniform PushConstants {
    uint submesh_buffer;
	uint mesh_info_buffer;
	uint draw_commands_buffer;
	uint entity_buffer;
	uint cull_info_buffer;
};

layout (local_size_x = 256) in;

float largest_scale_from_matrix(mat3 matrix) {
	vec3 x = matrix[0];
	vec3 y = matrix[1];
	vec3 z = matrix[2]; 

	float largest_scale_sqr = max(dot(x, x), max(dot(y, y), dot(z, z)));
	return sqrt(largest_scale_sqr);
}

vec4 transform_sphere(mat4 matrix, vec4 sphere) {
	vec4 bounding_sphere = matrix * vec4(sphere.xyz, 1.0);
	bounding_sphere.w = sphere.w * largest_scale_from_matrix(mat3(matrix));

	return bounding_sphere;
}

bool aabb_plane_test(vec3 box_min, vec3 box_max, vec4 plane) {
	vec3 c = (box_max + box_min) * 0.5f; // Compute AABB center
    vec3 e = box_max - c; // Compute positive extents

    // Compute the projection interval radius of b onto L(t) = b.c + t * p.n
    float radius = e.x * abs(plane.x) + e.y * abs(plane.y) + e.z * abs(plane.z);

    float center_distance = dot(plane.xyz, c) - plane.w;

    return center_distance > radius;
}

bool is_aabb_inside_frustum(mat4 mvp_matrix, Aabb aabb, uint plane_mask) {
	bool inside_frustum = true;

	vec3 aabb_min = vec3(aabb.min_pos[0], aabb.min_pos[1], aabb.min_pos[2]);
	vec3 aabb_max = vec3(aabb.max_pos[0], aabb.max_pos[1], aabb.max_pos[2]);

	mat4 mvp_t = transpose(mvp_matrix);
	vec4 planes[6];
	planes[0] = mvp_t[3] + mvp_t[0];
	planes[1] = mvp_t[3] - mvp_t[0];
	planes[2] = mvp_t[3] + mvp_t[1];
	planes[3] = mvp_t[3] - mvp_t[1];
	planes[4] = mvp_t[3] + mvp_t[2];
	planes[5] = mvp_t[3] - mvp_t[2];

	for (uint i = 0; i < 5; i += 1) {
		inside_frustum = inside_frustum && (
			(plane_mask & (1 << i)) == 0 ||
			!aabb_plane_test(aabb_min, aabb_max	, vec4(-planes[i].xyz, planes[i].w))
		);
	}

	return inside_frustum;
}

// 2D Polyhedral Bounds of a Clipped, Perspective-Projected 3D Sphere. Michael Mara, Morgan McGuire. 2013
bool project_sphere(vec4 sphere, float znear, float P00, float P11, out vec4 aabb) {
	vec3 C = sphere.xyz;
	float r = sphere.w;

	if (C.z < r + znear) return false;

	vec2 cx = -C.xz;
	vec2 vx = vec2(sqrt(dot(cx, cx) - r * r), r);
	vec2 minx = mat2(vx.x, vx.y, -vx.y, vx.x) * cx;
	vec2 maxx = mat2(vx.x, -vx.y, vx.y, vx.x) * cx;

	vec2 cy = -C.yz;
	vec2 vy = vec2(sqrt(dot(cy, cy) - r * r), r);
	vec2 miny = mat2(vy.x, vy.y, -vy.y, vy.x) * cy;
	vec2 maxy = mat2(vy.x, -vy.y, vy.y, vy.x) * cy;

	aabb = vec4(minx.x / minx.y * P00, miny.x / miny.y * P11, maxx.x / maxx.y * P00, maxy.x / maxy.y * P11);
	aabb = aabb.xwzy * vec4(0.5f, -0.5f, 0.5f, -0.5f) + vec4(0.5f); // clip space -> uv space

	return true;
}

void main() {
	GetBuffer(DrawCommandsBuffer, draw_commands_buffer).count = 0;
	memoryBarrier();
    uint gID = gl_GlobalInvocationID.x;
	if (gID < GetBuffer(SubmeshBuffer, submesh_buffer).count) {
		Submesh submesh = GetBuffer(SubmeshBuffer, submesh_buffer).submeshes[gID];
		MeshInfo mesh_info = GetBuffer(MeshInfoBuffer, mesh_info_buffer).mesh_infos[submesh.mesh_index];
		EntityData entity_data = GetBuffer(EntityBuffer, entity_buffer).entities[submesh.entity_index];

		CullInfo cull_info = GetBuffer(CullInfoBuffer, cull_info_buffer).cull_info;
		
		bool should_include = bool((1 << submesh.alpha_mode) & cull_info.alpha_mode_flag);
		
		bool visible = true;

		// first occlusion pass: only proccess if submesh was visible last frame
		if (cull_info.occlusion_pass == 1) {
			// each bit corresponds to a submesh
			uint visibility_bitset = GetBuffer(VisibilityBuffer, cull_info.visibility_buffer).submeshes[gID / 32];
			visible = (visibility_bitset & (1 << (gID % 32))) > 0;
		}

		vec4 model_space_bounding_sphere = vec4(
			mesh_info.bounding_sphere[0],
			mesh_info.bounding_sphere[1],
			mesh_info.bounding_sphere[2],
			mesh_info.bounding_sphere[3]
		);
		vec4 view_space_sphere = transform_sphere(
			cull_info.view_matrix * entity_data.model_matrix,
			model_space_bounding_sphere
		);

		// // first occlusion pass: only proccess if submesh was visible last frame
		// if (cull_info.occlusion_pass == 1)
		// 	visible = GetBuffer(VisibilityBuffer, cull_info.visibility_buffer).submeshes[gID] == 1;

		// frustum culling
		if (visible) {
			for (uint i = 0; i < cull_info.cull_plane_count; i++) {
				vec4 plane = cull_info.cull_planes[i];
				float point_plane_distance = dot(plane.xyz, view_space_sphere.xyz) + plane.w;
				bool inside_frustum = point_plane_distance > -view_space_sphere.w;
				visible = visible && inside_frustum;
			}
		}

		// occlusion cull
		if (cull_info.occlusion_pass == 2 && visible) {
			view_space_sphere.z = -view_space_sphere.z;

			vec4 aabb;
			if (project_sphere(
				view_space_sphere,
				cull_info.z_near,
				cull_info.p00,
				cull_info.p11,
				aabb
			)) {
				vec2 pyramid_size = textureSize(GetSampledTexture2D(cull_info.depth_pyramid), 0);
				float width = (aabb.z - aabb.x) * pyramid_size.x;
				float height = (aabb.w - aabb.y) * pyramid_size.y;

				// sample the depth pyramid at that specific level
				float depth = textureLod(
					sampler2D(GetTexture2D(cull_info.depth_pyramid), GetSampler(REDUCE_MIN_SAMPLER)),
					(aabb.xy + aabb.zw) * 0.5,
					log2(max(width, height))
				).x;

				float depthSphere = cull_info.z_near / (view_space_sphere.z - view_space_sphere.w);

				//if the depth of the sphere is in front of the depth pyramid value, then the object is visible
				visible = depthSphere >= depth;
			}
		}

		bool should_draw = visible && should_include;

		// second occlusion pass: only proccess if submesh wasn't visible last frame
		// if (cull_info.occlusion_pass == 2)
		// 	should_draw = visible && GetBuffer(VisibilityBuffer, cull_info.visibility_buffer).submeshes[gID] != 1;

		// draw command fill
		if (should_draw) {
			DrawCommand draw_command;
			draw_command.index_count 	  = mesh_info.index_count;
			draw_command.instance_count   = 1;
			draw_command.first_index      = mesh_info.index_offset;
			draw_command.vertex_offset    = mesh_info.vertex_offset;
			draw_command.first_instance   = submesh.entity_index;
			draw_command.material_index   = submesh.material_index;
			draw_command._debug_index     = gID;

			uint draw_index = atomicAdd(GetBuffer(DrawCommandsBuffer, draw_commands_buffer).count, 1);
			GetBuffer(DrawCommandsBuffer, draw_commands_buffer).commands[draw_index] = draw_command;
		}

		// update visibility buffer, only on second occlusion pass
		if (cull_info.occlusion_pass == 2) {
			// this should also work on AMD, but i can't test it
			for (uint i = 0; i < gl_SubgroupSize / 32; i++) {
				// only the invocatons responsible for the current bit are active
				if (32 * i <= gl_SubgroupInvocationID && gl_SubgroupInvocationID < 32 * (i + 1)) {
					uint visiblity_bitset = subgroupOr(uint(visible) << (gID % 32));
					if (subgroupElect()) {
						GetBuffer(VisibilityBuffer, cull_info.visibility_buffer).submeshes[gID / 32] = visiblity_bitset;
					}
				}
			}
		}
	}
}